{"meta":{"title":"Ai Trading","subtitle":null,"description":"致力于智能量化交易","author":"时应盼","url":"http://aijy.github.io"},"pages":[{"title":"","date":"2018-04-13T06:18:50.564Z","updated":"2018-04-13T06:18:50.564Z","comments":true,"path":"404.html","permalink":"http://aijy.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2017-12-31T16:00:00.000Z","updated":"2018-05-31T06:33:06.988Z","comments":true,"path":"about/index.html","permalink":"http://aijy.github.io/about/index.html","excerpt":"","text":"本博客旨在于分享量化交易、智能交易技术！"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-04-13T06:18:51.148Z","comments":false,"path":"categories/index.html","permalink":"http://aijy.github.io/categories/index.html","excerpt":"","text":""},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-04-13T06:18:51.123Z","comments":true,"path":"archives/index.html","permalink":"http://aijy.github.io/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-04-13T06:18:51.338Z","comments":true,"path":"tags/index.html","permalink":"http://aijy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"MQL4进阶课程","date":"2019-02-12T05:45:41.807Z","updated":"2019-02-12T05:45:41.819Z","comments":true,"path":"MQL4进阶课程.html","link":"","permalink":"http://aijy.github.io/MQL4进阶课程.html","excerpt":"进阶课程 title: “MQL4进阶课程”date: “2018-04-16”categories: MQL4课程tags: [教程] comments: true本教程是属于视频课程的配套课程，课程时间预计4小时","text":"进阶课程 title: “MQL4进阶课程”date: “2018-04-16”categories: MQL4课程tags: [教程] comments: true本教程是属于视频课程的配套课程，课程时间预计4小时 指标的调用均线指标1234567891011121314151617181920212223#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;//---------- 默认币种4小时周期，前三根K线14日均线值 -----------// string 币种=Symbol(); //----币种Symbol为图表币种，也可直接定义如“EURUSD” int 时间周期=240; //----时间周期指图表周期，240（分钟）是4小时图，使用0，则默认图表周期 int 均线周期=14; //----均线周期，本例指14均线 double ma_0=iMA(币种,时间周期,均线周期,0,MODE_EMA,PRICE_CLOSE,0); //---最后一个参数表示第几根k线，0是从右往左第一根，即最近的一根K线 double ma_1=iMA(币种,时间周期,均线周期,0,MODE_EMA,PRICE_CLOSE,1); //---第二根，从右往左。注意第n+1根K线的标号为n。 double ma_2=iMA(币种,时间周期,均线周期,0,MODE_EMA,PRICE_CLOSE,2); PrintFormat(\"前三根K线均线值为：%.5f,%.5f,%.5f\",ma_0,ma_1,ma_2); //---------- 获取 EURUSD 日线50日周期的前日收盘均线值 -----------// double ma_eurusd=iMA(\"EURUSD\",PERIOD_D1,50,0,MODE_EMA,PRICE_CLOSE,1); PrintFormat(\"EURUSD的均线值为：%.5f\",ma_eurusd); &#125; MACD指标12345678910111213141516171819202122232425#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;/* 设置币种4小时周期，前根K线MACD值,MACD有2个返回值macd的值，与macd的均线值*/ string 币种=Symbol(); //----币种Symbol为图表币种，也可直接定义如“EURUSD” int 时间周期=240; //----时间周期指图表周期，240（分钟）是4小时图，使用0，则默认图表周期 int 慢周期=26,快周期=12,均滑周期=9; double macd_main=iMACD(币种,时间周期,快周期,慢周期,均滑周期,PRICE_CLOSE,MODE_MAIN,1); //---最后一个参数表示第几根k线，0是从右往左第一根，即最近的一根K线 double macd_signal=iMACD(币种,时间周期,快周期,慢周期,均滑周期,PRICE_CLOSE,MODE_SIGNAL,1); //---第二根，从右往左。注意第n+1根K线的标号为n。 PrintFormat(\"MACD值为：%.5f,SIGNAL：%.5f\",macd_main,macd_signal); //---------- 获取 EURUSD 日线当前MACD值 -----------// macd_main=iMACD(\"EURUSD\",PERIOD_D1,快周期,慢周期,均滑周期,PRICE_CLOSE,MODE_MAIN,0); //---最后一个参数表示第几根k线，0是从右往左第一根，即最近的一根K线 macd_signal=iMACD(\"EURUSD\",PERIOD_D1,快周期,慢周期,均滑周期,PRICE_CLOSE,MODE_SIGNAL,0); //---第二根，从右往左。注意第n+1根K线的标号为n。 PrintFormat(\"MACD值为：%.5f,SIGNAL：%.5f\",macd_main,macd_signal); &#125; 布林线123456789101112131415161718192021222324252627#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;/* 设置币种4小时周期，前根K线布林线上、中、下轨值*/ string 币种=Symbol(); //----币种Symbol为图表币种，也可直接定义如“EURUSD” int 时间周期=240; //----时间周期指图表周期，240（分钟）是4小时图，使用0，则默认图表周期 int 布林线周期=20,布林线方差=2; double bands_upper =iBands(币种,时间周期,布林线周期,布林线方差,0,PRICE_CLOSE,MODE_UPPER,1); //---第二根k线，布林线上轨值 double bands_middle =iBands(币种,时间周期,布林线周期,布林线方差,0,PRICE_CLOSE,MODE_MAIN,1); //---第二根k线，布林线中轨值 double bands_lower =iBands(币种,时间周期,布林线周期,布林线方差,0,PRICE_CLOSE,MODE_LOWER,1); //---第二根k线，布林线下轨值 PrintFormat(\"4小时布林线前K线上轨值：%.5f,中轨值：%.5f,下轨值：%.5f\",bands_upper,bands_middle,bands_lower); //---------- 获取 EURUSD 日线当前布林线值 -----------// bands_upper =iBands(\"EURUSD\",PERIOD_D1,20,2,0,PRICE_CLOSE,MODE_UPPER,0); //--- 布林线上轨值 bands_middle =iBands(\"EURUSD\",PERIOD_D1,20,2,0,PRICE_CLOSE,MODE_MAIN,0); //--- 布林线中轨值 bands_lower =iBands(\"EURUSD\",PERIOD_D1,20,2,0,PRICE_CLOSE,MODE_LOWER,0); //--- 布林线下轨值 PrintFormat(\"当前日线布林线上轨值：%.5f,中轨值：%.5f,下轨值：%.5f\",bands_upper,bands_middle,bands_lower); &#125; RSI1234567891011121314151617181920212223#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;//---------- 设置币种4小时周期，前三根K线14日RSI值 -----------// string 币种=Symbol(); //----币种Symbol为图表币种，也可直接定义如“EURUSD” int 时间周期=240; //----时间周期指图表周期，240（分钟）是4小时图，使用0，则默认图表周期 int RSI周期=14; //----均线周期，本例指14均线 double rsi_0=iRSI(币种,时间周期,RSI周期,PRICE_CLOSE,0); //---最后一个参数表示第几根k线，0是从右往左第一根，即最近的一根K线 double rsi_1=iRSI(币种,时间周期,RSI周期,PRICE_CLOSE,1); //---第二根，从右往左。注意第n+1根K线的标号为n。 double rsi_2=iRSI(币种,时间周期,RSI周期,PRICE_CLOSE,2); PrintFormat(\"前三根K线RSI值为：%.5f,%.5f,%.5f\",rsi_0,rsi_1,rsi_2); //---------- 获取 EURUSD 日线日收盘RSI值 -----------// double rsi_eurusd=iRSI(\"EURUSD\",PERIOD_D1,14,PRICE_CLOSE,1); PrintFormat(\"EURUSD日线的RSI值为：%.5f\",rsi_eurusd); &#125; KD指标12345678910111213141516171819202122232425#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;/* 设置币种4小时周期，前根K线KD值,KD有2个返回值K值，与D值*/ string 币种=Symbol(); //----币种Symbol为图表币种，也可直接定义如“EURUSD” int 时间周期=240; //----时间周期指图表周期，240（分钟）是4小时图，使用0，则默认图表周期 int K周期=5,D周期=3,均滑周期=3; double kd_main=iStochastic(币种,时间周期,K周期,D周期,均滑周期,MODE_EMA,0,MODE_MAIN,1); //---最后一个参数表示第几根k线，0是从右往左第一根，即最近的一根K线 double kd_signal=iStochastic(币种,时间周期,K周期,D周期,均滑周期,MODE_EMA,0,MODE_SIGNAL,1); //---第二根，从右往左。注意第n+1根K线的标号为n。 PrintFormat(\"KD值为：%.5f,SIGNAL：%.5f\",kd_main,kd_signal); //---------- 获取 EURUSD 日线当前KD值 -----------// kd_main=iStochastic(\"EURUSD\",PERIOD_D1,5,3,3,MODE_EMA,0,MODE_MAIN,0); //---最后一个参数表示第几根k线，0是从右往左第一根，即最近的一根K线 kd_signal=iStochastic(\"EURUSD\",PERIOD_D1,5,3,3,MODE_EMA,0,MODE_SIGNAL,0); //---第二根，从右往左。注意第n+1根K线的标号为n。 PrintFormat(\"KD值为：%.5f,SIGNAL：%.5f\",kd_main,kd_signal); &#125; 其他系统自带指标其他系统自带指标参照帮助文件中的指标调用方式调用，调用形式都是一样的。 自定义指标12345678910111213141516171819202122232425262728293031323334353637#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;//---------- 调用自定义指标，指标需在指标文件夹中 -----------// /*---- iCustom用法 iCustom(货币对名称, 时间周期, 指标名, 指标输入参数1,指标输入参数2,第几个数据,第几根K线); */ string 币种=Symbol(); //----币种Symbol为图表币种，也可直接定义如“EURUSD” int 时间周期=240; //----时间周期指图表周期，240（分钟）是4小时图，使用0，则默认图表周期 string 指标名=\"RSI\"; double value_0=iCustom(币种,时间周期,指标名,14,0,0); //---最后一个参数表示第几根k线，0是从右往左第一根，即最近的一根K线 double value_1=iCustom(币种,时间周期,指标名,14,0,1); //---第二根，从右往左。注意第n+1根K线的标号为n。 double value_2=iCustom(币种,时间周期,指标名,14,0,2); PrintFormat(\"前三根K线RSI值为：%.5f,%.5f,%.5f\",value_0,value_1,value_2); //---------- 获取 EURUSD 日线的zigzag值 -----------// double zz_value=0; double position=0; for(int i=0;i&lt;100;i++) &#123; zz_value=iCustom(\"EURUSD\", PERIOD_D1, \"ZigZag\", 12, 5, 3, 0, i); if(zz_value!=0) &#123; position=i; break; &#125; &#125; PrintFormat(\"EURUSD日线上个峰值/底值为：%.5f,第%d根K线\",zz_value,position); &#125; 基于KD指标的下单程序本例有以下几个要点： 移动止损 一根K线下一次单 如何避免无限重复下单 交易时间限制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictinput double 单量=1;input int 止损=400;input int 移动止损=100;input int 启动移动止损=300;input int 交易开始时间=2;input int 交易停止时间=22;int Magic_num=445678;datetime trade_time;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+int OnInit() &#123;//---//--- return(INIT_SUCCEEDED); &#125;//+------------------------------------------------------------------+//| Expert deinitialization function |//+------------------------------------------------------------------+void OnDeinit(const int reason) &#123;//--- &#125;//+------------------------------------------------------------------+//| Expert tick function |//+------------------------------------------------------------------+void OnTick() &#123; if(AccountNumber()==0) //----通过判断账户号，确定是否连接网络 return; double kd15_main,kd15_main_prv,kd15_sig,kd15_sig_prv; int ticket; bool long_order_exist=false,short_order_exist=false; for(int i=OrdersTotal()-1;i&gt;=0;i--) &#123; if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES) &amp;&amp; OrderSymbol()==Symbol()) &#123; if(OrderType()==OP_BUY &amp;&amp; OrderMagicNumber()==Magic_num) &#123; long_order_exist=true; //--首先价格要超过启动止损位置，然后还要比当前止损大 移动止损以上 if(Bid&gt;(OrderOpenPrice()+启动移动止损*Point) &amp;&amp; (Bid-OrderStopLoss())&gt;移动止损*Point) OrderModify(OrderTicket(),OrderOpenPrice(),Bid-移动止损*Point,0,0,clrNONE);// 设置移动止损 &#125; if(OrderType()==OP_SELL &amp;&amp; OrderMagicNumber()==Magic_num) &#123; short_order_exist=true; if(Ask&lt;(OrderOpenPrice()-启动移动止损*Point) &amp;&amp; (OrderStopLoss()-Ask)&gt;移动止损*Point) OrderModify(OrderTicket(),OrderOpenPrice(),Ask+移动止损*Point,0,0,clrNONE);// 设置移动止损 &#125; &#125; &#125; //-- TimeHour() 函数返回 时间参数 的小时数 if(TimeHour(TimeCurrent())&gt;=交易停止时间 || TimeHour(TimeCurrent())&lt;交易开始时间) //---------在流动性差的时间段不交易（点差高） return; if(trade_time==iTime(Symbol(),PERIOD_M15,0)) //---每隔15分钟计算一次是否要下单 &#123; return; &#125; trade_time=iTime(Symbol(),PERIOD_M15,0); kd15_main=iStochastic(Symbol(),PERIOD_M15,5,3,3,MODE_EMA,0,MODE_MAIN,1); kd15_sig=iStochastic(Symbol(),PERIOD_M15,5,3,3,MODE_EMA,0,MODE_SIGNAL,1); kd15_main_prv=iStochastic(Symbol(),PERIOD_M15,5,3,3,MODE_EMA,0,MODE_MAIN,2); kd15_sig_prv=iStochastic(Symbol(),PERIOD_M15,5,3,3,MODE_EMA,0,MODE_SIGNAL,2); if(long_order_exist==false) //---当前有多单，就不再下多单 &#123; // 在35以下的金叉买入 if(kd15_main_prv&lt;kd15_sig_prv &amp;&amp; kd15_main&gt;kd15_sig &amp;&amp; kd15_main_prv&lt;35 &amp;&amp; kd15_sig_prv&lt;35 &amp;&amp; kd15_main&lt;35 &amp;&amp; kd15_sig&lt;35) &#123; ticket=OrderSend(Symbol(),OP_BUY,单量,Ask,3,Ask-止损*Point,0,\"KD_long\",Magic_num,0,clrRed); if(ticket==0) &#123; Print(\"open buy order error:\",GetLastError()); &#125; &#125; &#125; if(short_order_exist==false) //---当前有空单，就不再下空单 &#123; //--在65以上的死叉卖出 if(kd15_main_prv&gt;kd15_sig_prv &amp;&amp; kd15_main&lt;kd15_sig &amp;&amp; kd15_main_prv&gt;65 &amp;&amp; kd15_sig_prv&gt;65 &amp;&amp; kd15_main&gt;65 &amp;&amp; kd15_sig&gt;65) &#123; ticket=OrderSend(Symbol(),OP_SELL,单量,Bid,3,Bid+止损*Point,0,\"KD_short\",Magic_num,0,clrYellow); if(ticket==0) &#123; Print(\"open sell order error:\",GetLastError()); &#125; &#125; &#125; &#125; 指标的编写KD指标代码解读123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#property copyright \"2005-2014, MetaQuotes Software Corp.\"#property link \"http://www.mql4.com\"#property description \"Stochastic Oscillator\"#property strict#property indicator_separate_window //-- 显示在附图上,若要主图显示用 indicator_chart_window #property indicator_minimum 0 //-- 指标下限（可选） #property indicator_maximum 100 //-- 指标上限（可选） #property indicator_buffers 2 //-- 指标数据缓存，2表示这个指标有2个数据。非常重要#property indicator_color1 LightSeaGreen //-- 第一根指标线的颜色#property indicator_color2 Red //-- 第二根指标线的颜色#property indicator_level1 20.0 //-- 指标数值参考线#property indicator_level2 80.0 //-- 指标数值参考线#property indicator_levelcolor clrSilver //-- 指标数值参考线颜色（统一的颜色）#property indicator_levelstyle STYLE_DOT //-- 指标数值参考线类型（统一的类型），本例点线//--- input parametersinput int InpKPeriod=5; // K Period 参数定义与输入input int InpDPeriod=3; // D Periodinput int InpSlowing=3; // Slowing//-- 定义需要使用的缓存器,按需定义。只要要定义上面设置的数据缓存数目double ExtMainBuffer[]; //-- 定义主缓存空间double ExtSignalBuffer[]; //-- 定义Signal数值的缓存空间double ExtHighesBuffer[]; //-- 中间变量空间，供中间计算double ExtLowesBuffer[]; //-- 中间变量空间，供中间计算//---int draw_begin1=0;int draw_begin2=0;//+------------------------------------------------------------------+//| Custom indicator initialization function |//+------------------------------------------------------------------+int OnInit(void) &#123; string short_name;//--- 2 additional buffers are used for counting. IndicatorBuffers(4); //-- 声明4个缓存空间 SetIndexBuffer(2, ExtHighesBuffer); //-- 缓存空间与编号要一一对应，ExtHighesBuffer对应2 SetIndexBuffer(3, ExtLowesBuffer); //-- ExtLowesBuffer对应3，问题：为什么中间变量空间不对应0和1？ //-- 答：编号首先供指标缓存使用，然后才能给中间变量空间使用 //--- indicator lines SetIndexStyle(0,DRAW_LINE); //-- 设置数据1是线型 SetIndexBuffer(0, ExtMainBuffer); //-- 指定数据1的缓存空间 SetIndexStyle(1,DRAW_LINE); //-- 设置数据2是线型 SetIndexBuffer(1, ExtSignalBuffer); //-- 指定数据2的缓存空间//--- name for DataWindow and indicator subwindow label short_name=\"Sto(\"+IntegerToString(InpKPeriod)+\",\"+IntegerToString(InpDPeriod)+\",\"+IntegerToString(InpSlowing)+\")\"; IndicatorShortName(short_name); //--指标名 SetIndexLabel(0,short_name); //-- 数据1的名称 SetIndexLabel(1,\"Signal\"); //-- 数据2的名称//--- draw_begin1=InpKPeriod+InpSlowing; draw_begin2=draw_begin1+InpDPeriod; SetIndexDrawBegin(0,draw_begin1); //-- 数据1画线起始位置 SetIndexDrawBegin(1,draw_begin2); //-- 数据2画线起始位置//--- initialization done return(INIT_SUCCEEDED); &#125;//+------------------------------------------------------------------+//| Stochastic oscillator |//+------------------------------------------------------------------+int OnCalculate(const int rates_total, const int prev_calculated, const datetime &amp;time[], const double &amp;open[], const double &amp;high[], const double &amp;low[], const double &amp;close[], const long &amp;tick_volume[], const long &amp;volume[], const int &amp;spread[]) &#123; int i,k,pos;//--- rates_total是当前可用的K线数量，如果太小，则不能计算指标 if(rates_total&lt;=InpKPeriod+InpDPeriod+InpSlowing) return(0);//--- 指标的数据存储是按K线从左到右计算的，不需要反向 ArraySetAsSeries(ExtMainBuffer,false); ArraySetAsSeries(ExtSignalBuffer,false); ArraySetAsSeries(ExtHighesBuffer,false); ArraySetAsSeries(ExtLowesBuffer,false); ArraySetAsSeries(low,false); ArraySetAsSeries(high,false); ArraySetAsSeries(close,false);//--- pos=InpKPeriod-1; if(pos+1&lt;prev_calculated) //---prev_calculated表示未参与运算的K线数 pos=prev_calculated-2; else &#123; for(i=0; i&lt;pos; i++) //-- 通过for循环为最初没有用到的空间赋初值0 &#123; //-- 比如highbuffer是记录前5日的高点的，那么0-4的值是没有的，赋为0 ExtLowesBuffer[i]=0.0; ExtHighesBuffer[i]=0.0; &#125; &#125;//--- calculate HighesBuffer[] and ExtHighesBuffer[] for(i=pos; i&lt;rates_total &amp;&amp; !IsStopped(); i++) //-- 从未计算的K线开始，一直计算到所有K线 &#123; double dmin=1000000.0; double dmax=-1000000.0; for(k=i-InpKPeriod+1; k&lt;=i; k++) &#123; if(dmin&gt;low[k]) dmin=low[k]; //-- 前InpKPeriod（5）根K线的低点 if(dmax&lt;high[k]) dmax=high[k]; //-- 前InpKPeriod（5）根K线的高点 &#125; ExtLowesBuffer[i]=dmin; //-- ExtLowesBuffer[i]，指的是第i根K线前InpKPeriod（5）根K线的低点 ExtHighesBuffer[i]=dmax; //-- ExtLowesBuffer[i]，指的是第i根K线前InpKPeriod（5）根K线的低点 &#125;//--- 为未使用到的K值存储空间赋初值0 pos=InpKPeriod-1+InpSlowing-1; if(pos+1&lt;prev_calculated) pos=prev_calculated-2; else &#123; for(i=0; i&lt;pos; i++) ExtMainBuffer[i]=0.0; &#125;//--- 计算K值，主循环， for(i=pos; i&lt;rates_total &amp;&amp; !IsStopped(); i++) &#123; //-- 自定义指标的的数据缓存空间的计算主要在这个位置进行计算 //-- 以下是K值计算方法，每种指标计算方法不同，理解这种结构和操作形式即可 double sumlow=0.0; double sumhigh=0.0; for(k=(i-InpSlowing+1); k&lt;=i; k++) &#123; sumlow +=(close[k]-ExtLowesBuffer[k]); //-- 计算均滑（3）日的总和值。 sumhigh+=(ExtHighesBuffer[k]-ExtLowesBuffer[k]); &#125; if(sumhigh==0.0) ExtMainBuffer[i]=100.0; else ExtMainBuffer[i]=sumlow/sumhigh*100.0; &#125;//--- 计算D值，主循环 pos=InpDPeriod-1; if(pos+1&lt;prev_calculated) pos=prev_calculated-2; else &#123; for(i=0; i&lt;pos; i++) ExtSignalBuffer[i]=0.0; &#125; for(i=pos; i&lt;rates_total &amp;&amp; !IsStopped(); i++) &#123; double sum=0.0; for(k=0; k&lt;InpDPeriod; k++) sum+=ExtMainBuffer[i-k]; ExtSignalBuffer[i]=sum/InpDPeriod; &#125;//--- 到此计算结束，只要在计算中给缓存空间赋值即可，图表会根据数值和设定的图表类型自动画上去。 return(rates_total); &#125; 三色线指标代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/*--------------------------------本例制作一款趋势类型的变色均线指标，红色是跌势黄色是震荡绿线是上涨均线周期可选----------------------------------*/#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strict//---定义指标属性#property indicator_chart_window#property indicator_buffers 3#property indicator_color1 Red#property indicator_color2 Green#property indicator_color3 Yellow//---设置输入参数input int 短周期=10;input int 中周期=20;input int 长周期=30;//---定义指标缓存空间double LongBuffer[];double ShortBuffer[];double NoTrendBuffer[];//--- 指标起始点int draw_begin=0;int OnInit() &#123;//-- 为指标取个名字 string short_name=\"趋势指标(\"+IntegerToString(短周期)+IntegerToString(中周期)+IntegerToString(长周期)+\")\"; IndicatorShortName(short_name);//-- 设置指标缓存空间数量，设置线型并做连接,在此都设置为线型 IndicatorBuffers(3); SetIndexStyle(0,DRAW_LINE,STYLE_SOLID,2); SetIndexBuffer(0,LongBuffer); SetIndexStyle(1,DRAW_LINE,STYLE_SOLID,2); SetIndexBuffer(1,ShortBuffer); SetIndexStyle(2,DRAW_LINE,STYLE_SOLID,2); SetIndexBuffer(2,NoTrendBuffer);//-- 设置指标起始的地方,小于长周期的K线并没有值 draw_begin=长周期; SetIndexDrawBegin(0,draw_begin);//-- 返回初始化成功，若返回 INIT_FAILED则指标不会成功加载 return(INIT_SUCCEEDED); &#125;int OnCalculate(const int rates_total, const int prev_calculated, const datetime &amp;time[], const double &amp;open[], const double &amp;high[], const double &amp;low[], const double &amp;close[], const long &amp;tick_volume[], const long &amp;volume[], const int &amp;spread[]) &#123;//-- 若K线数量小于长周期数目，则不够计算 if(rates_total&lt;=长周期) return(0);//-- 缓存空间顺序是从左到右的，最左边是1 ArraySetAsSeries(LongBuffer,false); ArraySetAsSeries(ShortBuffer,false); ArraySetAsSeries(NoTrendBuffer,false); double ma_fast,ma_mid,ma_slow; double ma_fast_prv,ma_mid_prv,ma_slow_prv;//-- 为显示趋势变化快慢，为较短的周期赋予较大的权重 double sum=短周期+中周期+长周期; double w1=长周期/sum,w2=中周期/sum,w3=短周期/sum; for(int i=draw_begin+1; i&lt;=rates_total &amp;&amp; !IsStopped(); i++) &#123; ma_fast = iMA(Symbol(),0,短周期,0,MODE_EMA,PRICE_CLOSE,rates_total-i); ma_mid = iMA(Symbol(),0,中周期,0,MODE_EMA,PRICE_CLOSE,rates_total-i); ma_slow = iMA(Symbol(),0,长周期,0,MODE_EMA,PRICE_CLOSE,rates_total-i); ma_fast_prv = iMA(Symbol(),0,短周期,0,MODE_EMA,PRICE_CLOSE,rates_total-i+1); ma_mid_prv = iMA(Symbol(),0,中周期,0,MODE_EMA,PRICE_CLOSE,rates_total-i+1); ma_slow_prv = iMA(Symbol(),0,长周期,0,MODE_EMA,PRICE_CLOSE,rates_total-i+1); if(ma_fast&gt;ma_mid &amp;&amp; ma_mid&gt;ma_slow) //--- 多头排列，上涨趋势 &#123; LongBuffer[i]=(ma_fast+ma_mid+ma_slow)/3; //-- 计算本根和上一根的值，做不同趋势的连接 LongBuffer[i-1]=(ma_fast_prv+ma_mid_prv+ma_slow_prv)/3; //LongBuffer[i] =ma_fast*w1+ma_mid*w2+ma_slow*w3; //LongBuffer[i-1]=ma_fast_prv*w1+ma_mid_prv*w2+ma_slow_prv*w3; &#125; else if(ma_fast&lt;ma_mid &amp;&amp; ma_mid&lt;ma_slow) //--- 空头排列，下跌趋势 &#123; ShortBuffer[i]=(ma_fast+ma_mid+ma_slow)/3; ShortBuffer[i-1]=(ma_fast_prv+ma_mid_prv+ma_slow_prv)/3; //ShortBuffer[i] =ma_fast*w1+ma_mid*w2+ma_slow*w3; //ShortBuffer[i-1]=ma_fast_prv*w1+ma_mid_prv*w2+ma_slow_prv*w3; &#125; else //-- 除了上涨、下跌趋势，就是归纳于震荡 &#123; NoTrendBuffer[i]=(ma_fast+ma_mid+ma_slow)/3; NoTrendBuffer[i-1]=(ma_fast_prv+ma_mid_prv+ma_slow_prv)/3; //NoTrendBuffer[i] =ma_fast*w1+ma_mid*w2+ma_slow*w3; //NoTrendBuffer[i-1]=ma_fast_prv*w1+ma_mid_prv*w2+ma_slow_prv*w3; &#125; &#125; return(rates_total); &#125; 账户的操作 账号 账户名 账户资金 账户类型 账户净值风险控制1234567891011121314151617181920212223242526272829303132333435363738394041424344#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictint 授权账号=123;double 初始资金=0;int OnInit() &#123; while(AccountNumber()==0) //-- 加载前可先使用账户号判断时候可交易，网络未连接时，账号为0 Sleep(500); //-- 程序在此停留0.5秒，啥也不干，再判断账号值 if(AccountNumber()!=授权账号) &#123; Alert(\"非授权账号\"); return INIT_FAILED; //-- 非授权账号，不能加载成功 &#125; Print(\"账号名：\",AccountName()); //-- 获取账户名 初始资金=AccountEquity(); //-- 加载EA时获取当前账户净值 if(!IsDemo()) //-- 如果是实盘 &#123; Alert(\"当前账户为实盘账户！\"); &#125; return(INIT_SUCCEEDED); &#125;void OnDeinit(const int reason) &#123; &#125;void OnTick() &#123;//--------------- 账户净值风险控制 ----------------// if(AccountEquity()&lt;初始资金*0.8) &#123; Alert(\"当前账户净值亏损20%，已停止交易\"); //-- 添加平仓操作（平仓退出） ExpertRemove(); //-- 退出EA return; &#125; &#125; 文件夹操作文件夹操作可用于提取一定格式数据，用于分析。 提取隔夜利息1234567891011121314151617181920212223242526272829303132333435363738394041424344#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strict/* ------------------------------------------------------------------+本例统计平台的货币对隔夜利息//+-----------------------------------------------------------------*/string forex_name[29]=&#123;\"EURUSD\",\"AUDUSD\",\"GBPUSD\",\"NZDUSD\",\"USDJPY\",\"USDCAD\", \"USDCHF\",\"EURGBP\",\"EURJPY\",\"EURCHF\",\"EURCAD\",\"EURAUD\",\"EURNZD\",\"AUDCHF\",\"AUDJPY\",\"AUDNZD\",\"AUDCAD\",\"CADCHF\", \"CADJPY\",\"GBPCAD\",\"CHFJPY\",\"GBPAUD\",\"GBPNZD\",\"GBPJPY\",\"NZDCAD\",\"NZDJPY\",\"NZDCHF\",\"GBPCHF\",\"XAUUSD\"&#125;;string forex_data_name[58],file_name=\"隔夜利息.csv\";string first_line=\"forex_name\",second_line=\"LONG\",third_line=\"SHORT\";double swaplong[29],swapshort[29];void OnStart() &#123;//--- for(int i=0;i&lt;29;i++) &#123; first_line=first_line+\",\"+forex_name[i]; &#125; for(int i=0;i&lt;29;i++) &#123; swaplong[i]=MarketInfo(forex_name[i],MODE_SWAPLONG); swapshort[i]=MarketInfo(forex_name[i],MODE_SWAPSHORT); second_line=second_line+\",\"+DoubleToStr(swaplong[i],2); third_line=third_line+\",\"+DoubleToStr(swapshort[i],2); &#125; int handle=FileOpen(file_name,FILE_CSV|FILE_WRITE|FILE_ANSI,','); if(handle&gt;0) &#123; FileSeek(handle,0,SEEK_CUR); FileWrite(handle,first_line); FileWrite(handle,second_line); FileWrite(handle,third_line); &#125; FileClose(handle); &#125; 提取实时点差12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strict#property indicator_chart_windowstring forex_file_name;int handle;int spread1;int k=0;int flag=0;string spread_write;int count=0;int start_count=0;int OnInit() &#123;//--- indicator buffers mapping//--- return(INIT_SUCCEEDED); &#125;int OnCalculate(const int rates_total, const int prev_calculated, const datetime &amp;time[], const double &amp;open[], const double &amp;high[], const double &amp;low[], const double &amp;close[], const long &amp;tick_volume[], const long &amp;volume[], const int &amp;spread[]) &#123;//--- if(flag==0 &amp;&amp; DayOfWeek()==2) &#123; forex_file_name=Symbol()+\"_SPREAD.csv\"; spread_write=TimeToStr(TimeCurrent()); start_count=1; flag=1; handle=FileOpen(forex_file_name,FILE_CSV|FILE_WRITE,';'); &#125; if(start_count==1) &#123; RefreshRates(); spread1=MarketInfo(Symbol(),MODE_SPREAD); spread_write=spread_write+\";\"+spread1; count++; // Print(\"count:\",count); if(count==400) &#123; if(handle&gt;0) &#123; FileSeek(handle,0,SEEK_CUR); FileWriteString(handle,spread_write+\"\\r\\n\"); &#125; k=k+1; spread_write=TimeToStr(TimeCurrent()); count=0; if(k%1000==0) Print(\"k:\",k); &#125; if(k==300) &#123; FileClose(handle); start_count=0; Alert(\"data is full,time:\",TimeCurrent()); &#125; &#125;//--- return value of prev_calculated for next call return(rates_total); &#125; 编写马丁EA马丁策略是一种资金管理方式，它的基本原理基于金字塔式的加仓方式。在订单被套的时候，不断同方向间隔加仓，摊薄成本。只要行情回撤，就可以让被套的系列订单解套。https://www.jianshu.com/p/4ab42f1f761e 马丁策略优点 马丁策略的原理简单。只要死扛，资金量足够大，马丁在理论上不会爆仓。而市场行情总是在不同时间周期内来回切换摆动，一个回撤就可以解放所有的被套订单。 马丁策略的回撤是可计算的。马丁的加仓与回撤，在等间距、加仓倍数恒定的情况下，是可以事先计算出来的。这意味着马丁策略从数学意义上讲，是可以测算的。 马丁在程序化上代码编写的难度要小。相对于其它策略，马丁策略的代码编写难度要小。在外汇EA编写人才缺乏的现状下，受到各方开发者的青睐。 好的马丁策略，对付震荡型行情可以通杀完胜。马丁怕单边，爱震荡。在可测算的震荡型行情里，马丁策略可以达到大小通吃的完美结果，这对于自动化交易者来说，极具魅力。 代码实现为方便理解，本次代码分为多头马丁和空头马丁，多头马丁只会下买单，而空头马丁只会下空单。多头马丁：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563#property copyright \"aijy.github.io\"#property link \"https://aijy.github.io\"#property version \"1.00\"input bool UseAdd=true; // 是否使用加仓策略，true：是input double LotExponent=1; // 加仓系数input int slip=3; // 滑点input double Lots=0.05; // 初始单量input int LotsDigits=2; //单量精确到小数点后2位input double TakeProfit=200; // 止盈input double PipStep=300; // 加仓间隔，当一根K线的开盘价与上次开仓价之间价格大于这个数值，才加倍开仓input int MaxTrades=10; //最大订单数input bool UseEquityStop=true; //未使用input double TotalEquityRisk=20; //loss as a percentage of equityint MagicNumber=123456;double PriceTarget,StartEquity,BuyTarget,SellTarget;double AveragePrice,SellLimit,BuyLimit;double LastBuyPrice,LastSellPrice,ClosePrice,Spread;string EAName=\"BUY\";datetime timeprev=0;int NumOfTrades=0;double iLots;int cnt=0,total;bool TradeNow=false,LongTrade=false,ShortTrade=false;bool NewOrdersPlaced=false;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+int init() &#123; Spread=MarketInfo(Symbol(),MODE_SPREAD)*Point; return(0); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+int deinit() &#123; return(0); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+void OnTick() &#123;//---------开仓条件 bool long_trade=false; if(iClose(Symbol(),PERIOD_M1,2)&lt;iClose(Symbol(),PERIOD_M1,1)) long_trade=true;//------------------------//---获取平均的开仓价格---//------------------------ int ticket; total=CountTrades(); AveragePrice=0; double Count=0; for(cnt=OrdersTotal()-1;cnt&gt;=0;cnt--) &#123; if(OrderSelect(cnt,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_BUY || OrderType()==OP_SELL) &#123; AveragePrice=AveragePrice+OrderOpenPrice()*OrderLots(); Count=Count+OrderLots(); &#125; &#125; if(total&gt;0) AveragePrice=NormalizeDouble(AveragePrice/Count,Digits); for(int i=OrdersTotal()-1;i&gt;=0;i--) &#123; if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES) &amp;&amp; OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) &#123; if(OrderType()==OP_BUY) &#123; PriceTarget=AveragePrice+TakeProfit*Point; if(Bid&gt;PriceTarget &amp;&amp; PriceTarget&gt;0) &#123; CloseThisSymbolAll(); &#125; &#125; &#125; &#125; if(timeprev==Time[0]) &#123; return; &#125; timeprev=Time[0]; double CurrentPairProfit=CalculateProfit(); if(UseEquityStop) &#123; //当资金损失低于风险值，不再开仓 if(CurrentPairProfit&lt;0 &amp;&amp; MathAbs(CurrentPairProfit)&gt;(TotalEquityRisk/100)*AccountEquityHigh()) &#123; if(TimeCurrent()%120==0) Print(\"stop opening new orders\"); return; &#125; &#125; Print(\"货币对\"+Symbol()+\"的止盈:\",PriceTarget); total=CountTrades(); //计算本货币对订单总数（不包括其他货币对） NumOfTrades=total; double LastBuyLots; double LastSellLots; for(cnt=OrdersTotal()-1;cnt&gt;=0;cnt--) &#123; //统计所有订单，从中间查找本EA执行的本货币对订单，判断之前下的是多单还是空单，供后续使用 if(OrderSelect(cnt,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_BUY) &#123; LongTrade=true; ShortTrade=false; LastBuyLots=OrderLots(); break; &#125; if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_SELL) &#123; LongTrade=false; ShortTrade=true; LastSellLots=OrderLots(); break; &#125; &#125; if(total&gt;0 &amp;&amp; total&lt;=MaxTrades) //有订单且订单总量小于最大值 &#123; LastBuyPrice=FindLastBuyPrice(); //得到上次开仓的买价（多单） LastSellPrice=FindLastSellPrice();//得到上次开仓的卖价（空单） if(LongTrade &amp;&amp; (LastBuyPrice-Ask)&gt;=(PipStep*Point))//判断是否要增开多仓 &#123; TradeNow=true; &#125; if(ShortTrade &amp;&amp; (Bid-LastSellPrice)&gt;=(PipStep*Point))//判断是否要增开空仓 &#123; TradeNow=true; &#125; &#125; if(total&lt;1) //无订单的情况 &#123; ShortTrade=false; LongTrade=false; TradeNow=true; StartEquity=AccountEquity(); &#125; if(TradeNow &amp;&amp; total&gt;0) //如果之前判断要加仓则执行if &#123; LastBuyPrice=FindLastBuyPrice(); //得到上次开仓的买价（多单） LastSellPrice=FindLastSellPrice();//得到上次开仓的卖价（空单） if(ShortTrade) //如果是空仓 &#123; NumOfTrades=total; iLots=fGetLots(OP_SELL);//获得增加仓位的订单手数 if(UseAdd)//按以上计算出来的加仓手数下单 &#123; if(iLots&gt;0) &#123;//# RefreshRates(); ticket=OpenPendingOrder(OP_SELL,iLots,Bid,slip,Ask,0,0,EAName+\"-\"+IntegerToString(NumOfTrades),MagicNumber,0,HotPink); if(ticket&lt;0)&#123;Print(\"Error: \",GetLastError()); return;&#125; LastSellPrice=FindLastSellPrice(); TradeNow=false; NewOrdersPlaced=true; &#125;//# &#125; &#125; else if(LongTrade)//如果是多仓 &#123; NumOfTrades=total; iLots=fGetLots(OP_BUY);//获得增加仓位的订单手数 if(UseAdd)//按以上计算出来的加仓手数下单 &#123; if(iLots&gt;0) &#123;//# ticket=OpenPendingOrder(OP_BUY,iLots,Ask,slip,Bid,0,0,EAName+\"-\"+NumOfTrades,MagicNumber,0,Lime); if(ticket&lt;0) &#123;Print(\"Error: \",GetLastError()); return;&#125; LastBuyPrice=FindLastBuyPrice(); TradeNow=false; NewOrdersPlaced=true; &#125;//# &#125; &#125; &#125; if(TradeNow &amp;&amp; total&lt;1)//当前无本货币对订单，并且需要交易 &#123; SellLimit=Bid; BuyLimit=Ask; if(!ShortTrade &amp;&amp; !LongTrade)//当前既无多单又无空单 &#123; NumOfTrades=total; if(long_trade==true)//多单 &#123; iLots=fGetLots(OP_BUY); if(iLots&gt;0) &#123;//# ticket=OpenPendingOrder(OP_BUY,iLots,BuyLimit,slip,BuyLimit,0,0,EAName+\"-\"+NumOfTrades,MagicNumber,0,Lime); if(ticket&lt;0) &#123; Print(iLots,\"Error: \",GetLastError()); return; &#125; LastSellPrice=FindLastSellPrice(); NewOrdersPlaced=true; &#125;//# &#125; &#125; TradeNow=false; &#125;//------------------------------------------------------//---以平均开仓价格，计算出止损供所有本货币对仓位使用---//------------------------------------------------------ if(NewOrdersPlaced) for(cnt=OrdersTotal()-1;cnt&gt;=0;cnt--) &#123; if(OrderSelect(cnt,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_BUY) // Calculate profit/stop target for long &#123; PriceTarget=AveragePrice+(TakeProfit*Point); BuyTarget=PriceTarget; &#125; if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_SELL) // Calculate profit/stop target for short &#123; PriceTarget=AveragePrice-(TakeProfit*Point); SellTarget=PriceTarget; &#125; &#125; &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double fGetLots(int aTradeType) &#123; double tLots; tLots=NormalizeDouble(Lots*MathPow(LotExponent,NumOfTrades),LotsDigits); if(AccountFreeMarginCheck(Symbol(),aTradeType,tLots)&lt;=0) &#123; return(-1); &#125; if(GetLastError()==134) &#123; return(-2); &#125; return(tLots); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+int CountTrades() &#123; int count=0; int trade; for(trade=OrdersTotal()-1;trade&gt;=0;trade--) &#123; if(OrderSelect(trade,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_SELL || OrderType()==OP_BUY) count++; &#125;//for return(count); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+void CloseThisSymbolAll() &#123; int trade; for(trade=OrdersTotal()-1;trade&gt;=0;trade--) &#123; if(OrderSelect(trade,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) &#123; if(OrderType()==OP_BUY) OrderClose(OrderTicket(),OrderLots(),Bid,slip,Blue); if(OrderType()==OP_SELL) OrderClose(OrderTicket(),OrderLots(),Ask,slip,Red); &#125; Sleep(1000); &#125; &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+int OpenPendingOrder(int pType,double pLots,double pLevel,int sp,double pr,int sl,int tp,string pComment,int pMagic,datetime pExpiration,color pColor) &#123; int ticket=0; int err=0; int c=0; int NumberOfTries=100; switch(pType) &#123; case OP_BUYLIMIT: for(c=0;c&lt;NumberOfTries;c++) &#123; ticket=OrderSend(Symbol(),OP_BUYLIMIT,pLots,pLevel,sp,StopLong(pr,sl),TakeLong(pLevel,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(1000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; case OP_BUYSTOP: for(c=0;c&lt;NumberOfTries;c++) &#123; ticket=OrderSend(Symbol(),OP_BUYSTOP,pLots,pLevel,sp,StopLong(pr,sl),TakeLong(pLevel,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(5000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; case OP_BUY: for(c=0;c&lt;NumberOfTries;c++) &#123; RefreshRates(); ticket=OrderSend(Symbol(),OP_BUY,pLots,Ask,sp,StopLong(Bid,sl),TakeLong(Ask,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(5000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; case OP_SELLLIMIT: for(c=0;c&lt;NumberOfTries;c++) &#123; ticket=OrderSend(Symbol(),OP_SELLLIMIT,pLots,pLevel,sp,StopShort(pr,sl),TakeShort(pLevel,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(5000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; case OP_SELLSTOP: for(c=0;c&lt;NumberOfTries;c++) &#123; ticket=OrderSend(Symbol(),OP_SELLSTOP,pLots,pLevel,sp,StopShort(pr,sl),TakeShort(pLevel,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(5000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; case OP_SELL: for(c=0;c&lt;NumberOfTries;c++) &#123; ticket=OrderSend(Symbol(),OP_SELL,pLots,Bid,sp,StopShort(Ask,sl),TakeShort(Bid,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(5000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; &#125; return(ticket); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double StopLong(double price,int stop) &#123; if(stop==0) return(0); else return(price-(stop*Point)); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double StopShort(double price,int stop) &#123; if(stop==0) return(0); else return(price+(stop*Point)); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double TakeLong(double price,int take) &#123; if(take==0) return(0); else return(price+(take*Point)); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double TakeShort(double price,int take) &#123; if(take==0) return(0); else return(price-(take*Point)); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double CalculateProfit() &#123; double Profit=0; for(cnt=OrdersTotal()-1;cnt&gt;=0;cnt--) &#123; if(OrderSelect(cnt,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_BUY || OrderType()==OP_SELL) &#123; Profit=Profit+OrderProfit(); &#125; &#125; return(Profit); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double AccountEquityHigh() &#123; static double AccountEquityHighAmt,PrevEquity; if(CountTrades()==0) AccountEquityHighAmt=AccountEquity(); if(AccountEquityHighAmt&lt;PrevEquity) AccountEquityHighAmt=PrevEquity; else AccountEquityHighAmt=AccountEquity(); PrevEquity=AccountEquity(); return(AccountEquityHighAmt); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double FindLastBuyPrice() &#123; double oldorderopenprice=0,orderprice=0; int cnt_temp,oldticketnumber=0,ticketnumber; for(cnt_temp=OrdersTotal()-1;cnt_temp&gt;=0;cnt_temp--) &#123; if(OrderSelect(cnt_temp,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber &amp;&amp; OrderType()==OP_BUY) &#123; ticketnumber=OrderTicket(); if(ticketnumber&gt;oldticketnumber) &#123; orderprice=OrderOpenPrice(); oldorderopenprice=orderprice; oldticketnumber=ticketnumber; &#125; &#125; &#125; return(orderprice); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double FindLastSellPrice() &#123; double oldorderopenprice=0,orderprice=0; int cnt_temp,oldticketnumber=0,ticketnumber; for(cnt_temp=OrdersTotal()-1;cnt_temp&gt;=0;cnt_temp--) &#123; if(OrderSelect(cnt_temp,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber &amp;&amp; OrderType()==OP_SELL) &#123; ticketnumber=OrderTicket(); if(ticketnumber&gt;oldticketnumber) &#123; orderprice=OrderOpenPrice(); oldorderopenprice=orderprice; oldticketnumber=ticketnumber; &#125; &#125; &#125; return(orderprice); &#125;//+------------------------------------------------------------------+ 空头马丁：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585#property copyright \"aijy.github.io\"#property link \"https://aijy.github.io\"#property version \"1.00\"input bool UseAdd=true; // 是否使用加仓策略，true：是input double LotExponent=1; // 加仓系数input int slip=3; // 滑点input double Lots=0.05; // 初始单量input int LotsDigits=2; //单量精确到小数点后2位input double TakeProfit=200; // 止盈input double PipStep=300; // 加仓间隔，当一根K线的开盘价与上次开仓价之间价格大于这个数值，才加倍开仓input int MaxTrades=10; //最大订单数input bool UseEquityStop=true; //未使用input double TotalEquityRisk=20; //loss as a percentage of equityint MagicNumber=654321;double PriceTarget,StartEquity,BuyTarget,SellTarget;double AveragePrice,SellLimit,BuyLimit;double LastBuyPrice,LastSellPrice,ClosePrice,Spread;string EAName=\"SELL\";datetime timeprev=0,expiration;int NumOfTrades=0;double iLots;int cnt=0,total;double Stopper=0;bool TradeNow=false,LongTrade=false,ShortTrade=false;bool NewOrdersPlaced=false;int init() &#123; Spread=MarketInfo(Symbol(),MODE_SPREAD)*Point; return(0); &#125;int deinit() &#123; return(0); &#125;void OnTick() &#123;//---------开仓条件 bool sell_trade=false; if(iClose(Symbol(),PERIOD_M1,2)&gt;iClose(Symbol(),PERIOD_M1,1)) sell_trade=true;//------------------------//---获取平均的开仓价格---//------------------------ int ticket; total=CountTrades(); if(total&gt;=3) &#123; int total_profit=CalculateTotalProfit(); if(total_profit&gt;0) &#123; &#125; &#125; AveragePrice=0; double Count=0; for(cnt=OrdersTotal()-1;cnt&gt;=0;cnt--) &#123; if(OrderSelect(cnt,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_BUY || OrderType()==OP_SELL) &#123; AveragePrice=AveragePrice+OrderOpenPrice()*OrderLots(); Count=Count+OrderLots(); &#125; &#125; if(total&gt;0) AveragePrice=NormalizeDouble(AveragePrice/Count,Digits); for(int i=OrdersTotal()-1;i&gt;=0;i--) &#123; if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES) &amp;&amp; OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) &#123; if(OrderType()==OP_SELL) &#123; PriceTarget=AveragePrice-TakeProfit*Point; if(Ask&lt;PriceTarget) &#123; CloseThisSymbolAll(); &#125; &#125; &#125; &#125; if(timeprev==Time[0]) &#123; return; &#125; timeprev=Time[0]; double CurrentPairProfit=CalculateProfit(); if(UseEquityStop) &#123; //当资金损失低于风险值，不再开仓 if(CurrentPairProfit&lt;0 &amp;&amp; MathAbs(CurrentPairProfit)&gt;(TotalEquityRisk/100)*AccountEquityHigh()) &#123; if(TimeCurrent()%120==0) Print(\"stop opening new orders\"); return; &#125; &#125; Print(\"货币对\"+Symbol()+\"的止盈:\",PriceTarget); total=CountTrades(); //计算本货币对订单总数（不包括其他货币对） NumOfTrades=total; double LastBuyLots; double LastSellLots; for(cnt=OrdersTotal()-1;cnt&gt;=0;cnt--) &#123; //统计所有订单，从中间查找本EA执行的本货币对订单，判断之前下的是多单还是空单，供后续使用 if(OrderSelect(cnt,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_BUY) &#123; LongTrade=true; ShortTrade=false; LastBuyLots=OrderLots(); break; &#125; if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_SELL) &#123; LongTrade=false; ShortTrade=true; LastSellLots=OrderLots(); break; &#125; &#125; if(total&gt;0 &amp;&amp; total&lt;=MaxTrades) //有订单且订单总量小于最大值 &#123; LastBuyPrice=FindLastBuyPrice(); //得到上次开仓的买价（多单） LastSellPrice=FindLastSellPrice();//得到上次开仓的卖价（空单） if(LongTrade &amp;&amp; (LastBuyPrice-Ask)&gt;=(PipStep*Point))//判断是否要增开多仓 &#123; TradeNow=true; &#125; if(ShortTrade &amp;&amp; (Bid-LastSellPrice)&gt;=(PipStep*Point))//判断是否要增开空仓 &#123; TradeNow=true; &#125; &#125; if(total&lt;1) //无订单的情况 &#123; ShortTrade=false; LongTrade=false; TradeNow=true; StartEquity=AccountEquity(); &#125; if(TradeNow &amp;&amp; total&gt;0) //如果之前判断要加仓则执行if &#123; LastBuyPrice=FindLastBuyPrice(); //得到上次开仓的买价（多单） LastSellPrice=FindLastSellPrice();//得到上次开仓的卖价（空单） if(ShortTrade) //如果是空仓 &#123; NumOfTrades=total; iLots=fGetLots(OP_SELL);//获得增加仓位的订单手数 if(UseAdd)//按以上计算出来的加仓手数下单 &#123; if(iLots&gt;0) &#123;//# RefreshRates(); ticket=OpenPendingOrder(OP_SELL,iLots,Bid,slip,Ask,0,0,EAName+\"-\"+IntegerToString(NumOfTrades),MagicNumber,0,HotPink); if(ticket&lt;0)&#123;Print(\"Error: \",GetLastError()); return;&#125; LastSellPrice=FindLastSellPrice(); TradeNow=false; NewOrdersPlaced=true; &#125;//# &#125; &#125; else if(LongTrade)//如果是多仓 &#123; NumOfTrades=total; iLots=fGetLots(OP_BUY);//获得增加仓位的订单手数 if(UseAdd)//按以上计算出来的加仓手数下单 &#123; if(iLots&gt;0) &#123;//# ticket=OpenPendingOrder(OP_BUY,iLots,Ask,slip,Bid,0,0,EAName+\"-\"+NumOfTrades,MagicNumber,0,Lime); if(ticket&lt;0) &#123; Print(\"Error: \",GetLastError()); return; &#125; LastBuyPrice=FindLastBuyPrice(); TradeNow=false; NewOrdersPlaced=true; &#125;//# &#125; &#125; &#125; if(TradeNow &amp;&amp; total&lt;1)//当前无本货币对订单，并且需要交易 &#123; SellLimit=Bid; BuyLimit=Ask; if(!ShortTrade &amp;&amp; !LongTrade)//当前既无多单又无空单 &#123; NumOfTrades=total; if(sell_trade==true)//如果第二个K线收盘价大于第一根K线收盘价，下空单（首次下单的判定条件） &#123; iLots=fGetLots(OP_SELL); if(iLots&gt;0) &#123;//# ticket=OpenPendingOrder(OP_SELL,iLots,SellLimit,slip,SellLimit,0,0,EAName+\"-\"+NumOfTrades,MagicNumber,0,HotPink); if(ticket&lt;0) &#123; Print(iLots,\"Error: \",GetLastError()); return; &#125; LastBuyPrice=FindLastBuyPrice(); NewOrdersPlaced=true; &#125;//# &#125; &#125; TradeNow=false; &#125;//------------------------------------------------------//---以平均开仓价格，计算出止损供所有本货币对仓位使用---//------------------------------------------------------ if(NewOrdersPlaced) for(cnt=OrdersTotal()-1;cnt&gt;=0;cnt--) &#123; if(OrderSelect(cnt,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_BUY) // Calculate profit/stop target for long &#123; PriceTarget=AveragePrice+(TakeProfit*Point); BuyTarget=PriceTarget; &#125; if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_SELL) // Calculate profit/stop target for short &#123; PriceTarget=AveragePrice-(TakeProfit*Point); SellTarget=PriceTarget; &#125; &#125; &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double fGetLots(int aTradeType) &#123; double tLots; tLots=NormalizeDouble(Lots*MathPow(LotExponent,NumOfTrades),LotsDigits); if(AccountFreeMarginCheck(Symbol(),aTradeType,tLots)&lt;=0) &#123; return(-1); &#125; if(GetLastError()==134) &#123; return(-2); &#125; return(tLots); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+int CountTrades() &#123; int count=0; int trade; for(trade=OrdersTotal()-1;trade&gt;=0;trade--) &#123; if(OrderSelect(trade,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_SELL || OrderType()==OP_BUY) count++; &#125;//for return(count); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+void CloseThisSymbolAll() &#123; int trade; for(trade=OrdersTotal()-1;trade&gt;=0;trade--) &#123; if(OrderSelect(trade,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) &#123; if(OrderType()==OP_BUY) OrderClose(OrderTicket(),OrderLots(),Bid,slip,Blue); if(OrderType()==OP_SELL) OrderClose(OrderTicket(),OrderLots(),Ask,slip,Red); &#125; Sleep(1000); &#125; &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+int OpenPendingOrder(int pType,double pLots,double pLevel,int sp,double pr,int sl,int tp,string pComment,int pMagic,datetime pExpiration,color pColor) &#123; int ticket=0; int err=0; int c=0; int NumberOfTries=100; switch(pType) &#123; case OP_BUYLIMIT: for(c=0;c&lt;NumberOfTries;c++) &#123; ticket=OrderSend(Symbol(),OP_BUYLIMIT,pLots,pLevel,sp,StopLong(pr,sl),TakeLong(pLevel,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(1000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; case OP_BUYSTOP: for(c=0;c&lt;NumberOfTries;c++) &#123; ticket=OrderSend(Symbol(),OP_BUYSTOP,pLots,pLevel,sp,StopLong(pr,sl),TakeLong(pLevel,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(5000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; case OP_BUY: for(c=0;c&lt;NumberOfTries;c++) &#123; RefreshRates(); ticket=OrderSend(Symbol(),OP_BUY,pLots,Ask,sp,StopLong(Bid,sl),TakeLong(Ask,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(5000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; case OP_SELLLIMIT: for(c=0;c&lt;NumberOfTries;c++) &#123; ticket=OrderSend(Symbol(),OP_SELLLIMIT,pLots,pLevel,sp,StopShort(pr,sl),TakeShort(pLevel,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(5000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; case OP_SELLSTOP: for(c=0;c&lt;NumberOfTries;c++) &#123; ticket=OrderSend(Symbol(),OP_SELLSTOP,pLots,pLevel,sp,StopShort(pr,sl),TakeShort(pLevel,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(5000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; case OP_SELL: for(c=0;c&lt;NumberOfTries;c++) &#123; ticket=OrderSend(Symbol(),OP_SELL,pLots,Bid,sp,StopShort(Ask,sl),TakeShort(Bid,tp),pComment,pMagic,pExpiration,pColor); err=GetLastError(); if(err==0) &#123; break; &#125; else &#123; if(err==4 || err==137 || err==146 || err==136) //Busy errors &#123; Sleep(5000); continue; &#125; else //normal error &#123; break; &#125; &#125; &#125; break; &#125; return(ticket); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double StopLong(double price,int stop) &#123; if(stop==0) return(0); else return(price-(stop*Point)); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double StopShort(double price,int stop) &#123; if(stop==0) return(0); else return(price+(stop*Point)); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double TakeLong(double price,int take) &#123; if(take==0) return(0); else return(price+(take*Point)); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double TakeShort(double price,int take) &#123; if(take==0) return(0); else return(price-(take*Point)); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double CalculateProfit() &#123; double Profit=0; for(cnt=OrdersTotal()-1;cnt&gt;=0;cnt--) &#123; if(OrderSelect(cnt,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber) if(OrderType()==OP_BUY || OrderType()==OP_SELL) &#123; Profit=Profit+OrderProfit(); &#125; &#125; return(Profit); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double AccountEquityHigh() &#123; static double AccountEquityHighAmt,PrevEquity; if(CountTrades()==0) AccountEquityHighAmt=AccountEquity(); if(AccountEquityHighAmt&lt;PrevEquity) AccountEquityHighAmt=PrevEquity; else AccountEquityHighAmt=AccountEquity(); PrevEquity=AccountEquity(); return(AccountEquityHighAmt); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double FindLastBuyPrice() &#123; double oldorderopenprice=0,orderprice=0; int cnt_temp,oldticketnumber=0,ticketnumber; for(cnt_temp=OrdersTotal()-1;cnt_temp&gt;=0;cnt_temp--) &#123; if(OrderSelect(cnt_temp,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber &amp;&amp; OrderType()==OP_BUY) &#123; ticketnumber=OrderTicket(); if(ticketnumber&gt;oldticketnumber) &#123; orderprice=OrderOpenPrice(); oldorderopenprice=orderprice; oldticketnumber=ticketnumber; &#125; &#125; &#125; return(orderprice); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double FindLastSellPrice() &#123; double oldorderopenprice=0,orderprice=0; int cnt_temp,oldticketnumber=0,ticketnumber; for(cnt_temp=OrdersTotal()-1;cnt_temp&gt;=0;cnt_temp--) &#123; if(OrderSelect(cnt_temp,SELECT_BY_POS,MODE_TRADES)) if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==MagicNumber &amp;&amp; OrderType()==OP_SELL) &#123; ticketnumber=OrderTicket(); if(ticketnumber&gt;oldticketnumber) &#123; orderprice=OrderOpenPrice(); oldorderopenprice=orderprice; oldticketnumber=ticketnumber; &#125; &#125; &#125; return(orderprice); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+double CalculateTotalProfit() &#123; double Profit=0; for(cnt=OrdersTotal()-1;cnt&gt;=0;cnt--) &#123; if(OrderSelect(cnt,SELECT_BY_POS,MODE_TRADES) &amp;&amp; OrderMagicNumber()==MagicNumber) &#123; Profit=Profit+OrderProfit(); &#125; &#125; return(Profit); &#125; 马丁策略的改良方法马丁策略在单边行情越大时风险越大。下面，我们简单探讨一下马丁的风险控制。 在加仓间距上进行控制，使用较大的加仓可减小风险，过大的加仓间距可能迟迟不能盈利出场，这点比较难把控。 在加仓倍数上进行控制，使用较小的加仓倍数，策略会更稳健。 马丁也可以结合止盈止损，该止损的时候不能犹豫，如果真的触碰了止损线，就要反思参数设置的合理性了。 可以改变马丁加仓的位置，加仓的位置可以是K线有回调的时候才加。 EA的风险控制EA风险控制是重中之重。 净值风险控制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.0\"#property strictenum mybool&#123; 是=1, 否=0,&#125;;input mybool 是否手动输入净值=否; input double 手动输入初始资金=0;input double 净值风险率=15; //--- 净值亏损15%时，强平出场input double 盈利提示一=5; //--- 净值盈利到5%时，提示关注input double 盈利提示二=10; //--- 净值盈利到10%时，强平出场input double 亏损提示一=5; //--- 净值亏损到5%时，提示关注input double 亏损提示二=10; //--- 净值亏损到10%时，抢平出场double 初始资金=0;int flag[4]=&#123;0,0,0,0&#125;; //--- 净值浮动状态int OnInit() &#123; while(AccountNumber()==0) Sleep(10000);// 初始资金=AccountEquity(); if(是否手动输入净值==否) 初始资金=AccountBalance(); else 初始资金=手动输入初始资金; if(初始资金==0) &#123; Alert(\"当前账户无资金！\"); return(INIT_FAILED); &#125; if(AccountEquity()&lt;初始资金*(100-净值风险率)/100) &#123; Alert(\"当前净值亏损超过净值风险率，无法加载！\"); return(INIT_FAILED); &#125; return(INIT_SUCCEEDED); &#125;//+------------------------------------------------------------------+//| Expert deinitialization function |//+------------------------------------------------------------------+void OnDeinit(const int reason) &#123; &#125;void OnTick() &#123; if(AccountEquity()&lt;初始资金*(100-净值风险率)/100) &#123; Alert(\"资金亏损超过\"+DoubleToString(净值风险率,1)+\"%,全部平仓。亏损：\",DoubleToStr(AccountEquity()-初始资金,2),\" 净值：\",AccountEquity()); SendMail(\"资金亏损超过\"+DoubleToString(净值风险率,1)+\"%,全部平仓。亏损：\"+DoubleToStr(AccountEquity()-初始资金,2)+\" 净值：\"+DoubleToStr(AccountEquity()),\"\"); flag[1]=1;flag[2]=1; close_chart(); //改Return 为close_chart(); close_all(); Sleep(5000); &#125; if(AccountEquity()&lt;初始资金*(100-亏损提示一)/100 &amp;&amp; flag[1]==0) &#123; Alert(\"资金亏损超过\"+DoubleToString(亏损提示一,1)+\"%,亏损：\",DoubleToStr(AccountEquity()-初始资金,2),\" 净值：\",AccountEquity()); SendMail(\"资金亏损超过\"+DoubleToString(亏损提示一,1)+\"%,亏损：\"+DoubleToStr(AccountEquity()-初始资金,2)+\" 净值：\"+DoubleToStr(AccountEquity()),\"\"); flag[1]=1; return; &#125; if(AccountEquity()&lt;初始资金*(100-亏损提示二)/100 &amp;&amp; flag[2]==0) &#123; Alert(\"资金亏损超过\"+DoubleToString(亏损提示二,1)+\"%,亏损：\",DoubleToStr(AccountEquity()-初始资金,2),\" 净值：\",AccountEquity()); SendMail(\"资金亏损超过\"+DoubleToString(亏损提示二,1)+\"%,亏损：\"+DoubleToStr(AccountEquity()-初始资金,2)+\" 净值：\"+DoubleToStr(AccountEquity()),\"\"); flag[2]=1; close_chart(); close_all(); ExpertRemove(); Sleep(100000); return; &#125; if(AccountEquity()&gt;初始资金*(100+盈利提示一)/100 &amp;&amp; flag[3]==0) &#123; Alert(\"资金盈利超过\"+DoubleToString(盈利提示一,1)+\"%,盈利：\",DoubleToStr(AccountEquity()-初始资金,2),\" 净值：\",AccountEquity()); SendMail(\"资金盈利超过\"+DoubleToString(盈利提示一,1)+\"%,盈利：\"+DoubleToStr(AccountEquity()-初始资金,2)+\" 净值：\"+DoubleToStr(AccountEquity()),\"\"); flag[3]=1; return; &#125; if(AccountEquity()&gt;初始资金*(100+盈利提示二)/100 &amp;&amp; flag[4]==0) &#123; Alert(\"资金盈利超过\"+DoubleToString(盈利提示二,1)+\"%,盈利：\",DoubleToStr(AccountEquity()-初始资金,2),\" 净值：\",AccountEquity()); SendMail(\"资金盈利超过\"+DoubleToString(盈利提示二,1)+\"%,盈利：\"+DoubleToStr(AccountEquity()-初始资金,2)+\" 净值：\"+DoubleToStr(AccountEquity()),\"\"); flag[4]=1; close_chart(); close_all(); ExpertRemove(); Sleep(100000); return; &#125; Sleep(500); &#125;void close_all() //--- 平掉所有仓位&#123; int ticket[200],cnt=0; for(int i=0;i&lt;=OrdersTotal()-1;i++) &#123; if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)) &#123; ticket[cnt]=OrderTicket(); cnt++; &#125; &#125; for(int i=0;i&lt;=cnt-1;i++) &#123; if(OrderSelect(ticket[i],SELECT_BY_TICKET,MODE_TRADES)) &#123; if(OrderType()==OP_BUY) if(!OrderClose(OrderTicket(),OrderLots(),MarketInfo(OrderSymbol(),MODE_BID),3,clrRed)) OrderClose(OrderTicket(),OrderLots(),MarketInfo(OrderSymbol(),MODE_BID),3,clrRed); if(OrderType()==OP_SELL) if(!OrderClose(OrderTicket(),OrderLots(),MarketInfo(OrderSymbol(),MODE_ASK),3,clrRed)) OrderClose(OrderTicket(),OrderLots(),MarketInfo(OrderSymbol(),MODE_ASK),3,clrRed); if(OrderType()==OP_BUYLIMIT || OrderType()==OP_SELLLIMIT || OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP) if(!OrderDelete(OrderTicket(),clrRed)) OrderDelete(OrderTicket(),clrRed); &#125; &#125;&#125;void close_chart() //--- 关闭所有图表和EA&#123; long chart_total[100]; long currChart,prevChart=ChartFirst(); chart_total[0]=prevChart; int i=0,limit=100; while(i&lt;limit)// We have certainly not more than 100 open charts &#123; currChart=ChartNext(prevChart); // Get the new chart ID by using the previous chart ID if(currChart&lt;0) break; // Have reached the end of the chart list prevChart=currChart;// let's save the current chart ID for the ChartNext() i=i+1;// Do not forget to increase the counter chart_total[i]=prevChart; Print(i,chart_total[i]); &#125; for(int j=0;j&lt;=i;j++) if(chart_total[j]!=ChartID()) ChartClose(chart_total[j]);&#125; 单量风险控制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictinput double 万美金最大单量=2; //--- 一万美金可下几首单量，按比例缩减bool new_orders=true;double max_lots=0;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+int OnInit() &#123; while(AccountNumber()==0) Sleep(10000); max_lots=AccountEquity()/10000*万美金最大单量; return(INIT_SUCCEEDED); &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+void OnDeinit(const int reason) &#123; &#125;//+------------------------------------------------------------------+//| |//+------------------------------------------------------------------+void OnTick() &#123; double total_lots=0; for(int i=OrdersTotal()-1;i&gt;=0;i--) &#123; if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)) &#123; total_lots=total_lots+OrderLots(); &#125; &#125; if(total_lots&gt;max_lots) &#123; new_orders=false; &#125; if(new_orders==true) &#123; Print(\"当前单量未超最大单量，允许下单\"); &#125; &#125;","categories":[],"tags":[]},{"title":"博客最新更新计划","slug":"近期更新计划","date":"2018-06-01T00:00:00.000Z","updated":"2018-05-31T06:33:25.365Z","comments":true,"path":"近期更新计划.html","link":"","permalink":"http://aijy.github.io/近期更新计划.html","excerpt":"近期计划时间：2018.04.16内容：计划开始录制MQL4零基础课程","text":"近期计划时间：2018.04.16内容：计划开始录制MQL4零基础课程 历史内容时间：内容：","categories":[{"name":"博客计划","slug":"博客计划","permalink":"http://aijy.github.io/categories/博客计划/"}],"tags":[{"name":"最新更新","slug":"最新更新","permalink":"http://aijy.github.io/tags/最新更新/"}]},{"title":"MQL4零基础课程","slug":"MQL4零基础课程","date":"2018-05-16T00:00:00.000Z","updated":"2019-02-12T05:45:41.857Z","comments":true,"path":"MQL4零基础课程.html","link":"","permalink":"http://aijy.github.io/MQL4零基础课程.html","excerpt":"本教程是属于视频课程的配套课程,结合视频课程，效果更佳，课程时间预计4小时视频课程地址：https://www.bilibili.com/video/av39538742","text":"本教程是属于视频课程的配套课程,结合视频课程，效果更佳，课程时间预计4小时视频课程地址：https://www.bilibili.com/video/av39538742 初识 EA智能交易所谓EA智能外汇全自动交易系统，就是将您自己或别人的外汇交易策略用特殊的编程语言（MQL）编写成一个电脑软件程序（Expert Advisor）, 让电脑按照您事先设定好的条件自动地为您买卖与交易，当然赢亏结果取决于您的自动交易系统设计得好坏。 EA交易的优点： 由于是电脑自动下单，可以保证更快的下单，平仓速度，可以更敏感地响应价格变动和趋势变动。 电脑可以克服人性中的弱点，该买则买，该卖则卖，无犹豫，无贪心，赢则不狂妄，亏也不沮丧，避免了情绪化操作。 电脑可以每天24小时不间断地监控行情，并在适当的时机和点位自动进出场，完全不用人工的干预，可以让您夜晚安枕入眠，白天安心从事别的工作。 制作第一个外汇脚本只需1分钟，跟着视频的步骤来执行第一个EA程序吧1234// 将下面的代码复制到脚本中，这是一个下单指令//这是个以当前价格当前货币对开0.1手多单且无止损止盈的下单脚本 OrderSend(Symbol(),OP_BUY,0.1,Ask,3,0,0,&quot;多单&quot;,123,0,clrNONE); 编辑器操作 新建脚本脚本可以进行订单操作，在页面加载只执行一次，无需卸载。 1234void OnStart() &#123; 脚本主体 &#125; 新建指标自定义指标的编写比较复杂，将在进阶课程中讲解。 新建EA 1234567891011121314151617// EA初始化函数，在EA执行前需要确定的事情需要写在这个函数里面，比如网络连接是否正常，账户是否是确定账户等。int OnInit() &#123; return(INIT_SUCCEEDED); &#125;// 这个函数是EA卸载时执行的代码，一般不用，但保留格式void OnDeinit(const int reason) &#123; &#125;// 程序的主体内容写在这个函数里面，这个函数在图表货币对每次报价的时候执行一次。如果报价不变就不会执行，即周末的时候，报价不变，代码也不会执行。void OnTick() &#123; &#125; MQL4文件夹MQL4文件夹是MT4平台涉及智能交易的文件夹，其中EA，指标和脚本分别处于不同的文件夹中，放错位置将无法执行。 Experts ：存放EA Files ：MQL4可以进行文件操作，文件一般会在这个文件夹中 Images ： 用不到 Include ：函数库文件夹，用于存放函数库文件，在写EA和脚本时可以调用这个文件中的函数 Indicators ：指标文件夹，存放指标 Libraries ：动态链接库文件夹，借用动态链接库文件可扩展MQL4的功能 Logs ：日志文件夹，运行EA的日志存放在这个地方 Presets ：EA的参数可以保存，放在这个文件夹中 Project ：用不到 Scripts ：脚本文件夹，存放脚本 MetaEditor编辑器操作MetaEditor编辑器是专门用于编写MQL4语言的编辑器，需要掌握以下功能： 新建文档 : 创建新文件 编译文档 : 编写写好的代码 查看编译信息 ： 查看错误信息，调试代码 打开导航栏 : 方便查找文件 查看帮助文件 ： 帮助操作 变量变量,是指没有固定的值,在程序中可以改变的数。与之相对应的是不变量，即一旦设定，在整个程序中的值都不会变，也不允许改变。 注：程序中所有变量都需要先定义，后使用。 变量的定义变量的定义，有三个部分组成： 数据类型 变量名=初始值 结束符 数据类型：表明变量属于哪一类 变量名：是字母a-z,A-Z，数字0-9，以及“_”的组合，不能以字母开头。 结束符：分号“;”。分号必须为英文分号，代码中所有字符（除注释）必须为英文字符。 常量的定义常量的定义，有三部分 #define 常量名 常量值 不变量使用#define定义 不变量需在程序开始时定义。 不需要结束符 不变量的变量名，不能够再定义成变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strict//----常量的定义----//#define N 10 //常量标识符(#define) 常量名(N) 常量值(10) 注：不需要分号结束//----变量的定义----//int var=1; //数据类型(int) 变量名(var)=初始值(1) 结束符(;)double lot=1.2; //数据类型(double) 变量名(lot)=初始值(1.2) 结束符(;)void OnStart() &#123;//----- 整数-----// int a=1,b=2,c; c=a+b; Print(\"a=\",a,\",b=\",b,\",a+b=\",c); c=a-b; Print(\"a=\",a,\",b=\",b,\",a-b=\",c); c=a*b; Print(\"a=\",a,\",b=\",b,\",a*b=\",c); c=a/b; //----这是整除----// Print(\"a=\",a,\",b=\",b,\",a/b=\",c); c=a%b; Print(\"a=\",a,\",b=\",b,\",a%b=\",c);//----- 浮点数-----// double d=1,e=2,f; f=d+e; Print(\"d=\",d,\",e=\",e,\",d+e=\",f); f=d-e; Print(\"d=\",d,\",e=\",e,\",d-e=\",f); f=d*e; Print(\"d=\",d,\",e=\",e,\",d*e=\",f); f=d/e; Print(\"d=\",d,\",e=\",e,\",d/e=\",f);//----- 布尔量-----// bool g=true,h=false,i; i= g &amp;&amp; h; Print(\"g=\",g,\",h=\",h,\",g/h=\",i); i= g || h; Print(\"g=\",g,\",h=\",h,\",g/h=\",i);//----- 字符串-----// string j=\"ni\",k=\"hao\",m; m=j+k; Print(\"j=\",j,\",k=\",k,\",j/k=\",m);//----- 时间量-----// datetime now; now=TimeCurrent(); Print(\"now=\",now,\"now_int=\",int(now)); now=now-60; //----时间量可以转化为整型作为时间的计算方式，1个单位代表1秒 Print(\"now-60=\",now); //----- 颜色变量-----//// 颜色变量一般不定义，直接使用。 &#125; 数据类型整数整数是不带小数的数字，包含负整数，零和正整数。 整数的定义：int a=10; 整数转化为浮点数： b=double(a); 整数转化为字符串： string c=IntegerToString(a); 整除：整数除整数，结果仍然是整数，整数除浮点数，结果为浮点数。int a=1,b=2; Print(a/b);结果为0 浮点数浮点数是带有小数部分的数字。 浮点数的定义：double a=10; 浮点数转化为整数： b=int(a);只保留整数部分 浮点数转化为字符串： string c=DoubleToString(a，2);2表示保留2位小数 布尔量布尔量是表示真假的量，只有True（真）和False（假）两种情况。 布尔量的定义：bool a=True;布尔量一般不做类型转换。 字符串字符串可以理解为一段文字，可以是英文或中文。 字符串的定义：string a=”你好”；字符串需要用英文引号包含起来。 字符串转化为整型 :如果字符串中都是整数可转化为整数，b=StringToInteger(a) 字符串转化为浮点数：如果字符串是浮点数，则可以转化为浮点数，b=StringToDouble(a) 字符串转化为时间量 : 如果字符串是日期，则可以转化为时间量，b=StringToTime() 字符串的拼接：string a =”你”，b=”好”; c=a+b; Print(c); “你好” 时间量时间量是MQL4表示时间的变量。 时间量的定义：datetime a=D’2017.12.25 12:12:00’; 时，分，秒可以不写，默认为00:00:00 时间戳：以1970.01.01 为0，到现在的秒数，所以时间量也可以是整型，参与数学运算。 时间量转化为字符串：b=TimeToString(a) 颜色变量在MQL4中表示颜色的量，一般是使用的可用以下几种 红色：clrRed 黄色：clrYellow 白色：clrWhite 绿色：clrGreen 无颜色：clrNone 运算符加 数字相加 自加 时间相加 字符串相加 减 数字减 自减 时间减 乘在程序中，乘法符号用”“(shift+8)表示 int a=1,b=2; double c=ab; Print(c);输出 2 除在程序中，除法符号用”/“表示，除数不能为零。 int a=1;double b=2; double c=a/b;Print(c);输出 0.5 取余数取余数，又称为模运算，在程序中有重要的作用，取余数的符号是”%”(shift+5)，取余数的双方必须是整数。余数，类似于3除2，余1。 指数运算指数运算需要使用到系统自带的函数：MathPow(底数，次方数)。 逻辑运算逻辑运算符是配合控制语句使用。其运算结果是布尔量，只有“真”或“假”。 ==：等于等于，若两边一致，则为 True（真），否则为False（假） ！=：不等于，若两边不一致，则为True(真)，否则为False（假） > :大于，左边大于右边为True（真），否则为False（假） >= :大于等于，左边大于或等于右边为True（真），否则为False（假） &lt; :小于，左边小于于右边为True（真），否则为False（假） &lt;= :小于等于，左边小于或等于右边为True（真），否则为False（假） &amp;&amp; :逻辑与，左边和右边都为True(真)时，结果为True(真)，否则为False（假） || :逻辑或，左边和右边都为False（假）时，结果为False（假），否则为True（真）。 ！：非操作，也称取反操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;//-------加-------// int a=1; double b=2,c; c=a+b; Print(\"a=\",a,\",b=\",b,\",a+b=\",c); string j=\"ni\",k=\"hao\",m; m=j+k; Print(\"j=\",j,\",k=\",k,\",j/k=\",m); Print(\"a=\",a); a++; //自加1 Print(\"a\",a); //-------减-------// c=a-b; Print(\"a=\",a,\",b=\",b,\",a-b=\",c); Print(\"a=\",a); a--; //自加1 Print(\"a\",a); //-------乘-------// c=a*b; Print(\"a=\",a,\",b=\",b,\",a*b=\",c);//-------除-------// int aa=1,bb=2,cc; cc=aa/bb; //----这是整除----// Print(\"aa=\",aa,\",bb=\",bb,\",aa/bb=\",cc); double d=1,e=2,f; f=d/e; //----结果带小数---// Print(\"d=\",d,\",e=\",e,\",d/e=\",f);//-------取余-------// cc=aa%bb; //----这是整除取余----// Print(\"aa=\",aa,\",bb=\",bb,\",aa%bb=\",cc);//-------指数运算-------// c=MathPow(b,a); //----b的a次方----// Print(\"a=\",a,\",b=\",b,\",b^a=\",c);//-------逻辑运算-------// bool r; r= a&gt;b; Print(\"a=\",a,\",b=\",b,\",a&gt;b=\",r); r=!(a&gt;b); Print(\"a=\",a,\",b=\",b,\",a&gt;b=\",r); r= a&gt;=b; Print(\"a=\",a,\",b=\",b,\",a&gt;=b=\",r); r= a&lt;b; Print(\"a=\",a,\",b=\",b,\",a&lt;b=\",r); r= a&lt;=b; Print(\"a=\",a,\",b=\",b,\",a&lt;=b=\",r); r= a==b; Print(\"a=\",a,\",b=\",b,\",a==b=\",r); r= a&gt;b || a==b; Print(\"a=\",a,\",b=\",b,\",a&gt;b || a==b=\",r); r= a&gt;=b || a==b; Print(\"a=\",a,\",b=\",b,\",a&gt;=b || a==b=\",r); &#125; 标示程序中标示，包含自定义变量的名称，函数的名称等。标示的作用主要是便于读代码。 良好的标示有助于读懂代码，修改代码。 杂乱的标示会增加破译代码策略的难度。 保留字每种编程语言都会有些关键字，是保留下来的，不能够当变量名使用。保留字都有特定的颜色。不能够使用保留字的名称作为变量。 类型保留字 函数保留字 订单保留字 其他保留字 结束符在程序主体中，每句代码的结束，都要以英文分号”;”结束。 注释程序中注释不会影响程序的运行。 注释一行：使用”//“ 注释一段：使用”// 注释内容 //“ 12345678910111213141516171819202122232425262728293031#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;//保留字，系统留用。保留字有特殊的颜色//类型int,double,datetime,string//函数OrderSend(),OrderClose(),OnStart();//订单OP_BUY,OP_SELL//其他保留字Ask,Bid //中文字符 注意中文字符的颜色，MQL4支持中文字符。 //结束符每句代码的结束都要以英文分号(;)结束 // 这是一行注释/* 这是一段注释*/ &#125; 函数函数本质上是一段代码，只不过这段代码经常被使用或者这段代码实现特定的功能。函数并不是一定要用，用了有以下优势： 代码框架清晰 代码重用性提高，减少代码量 函数可以嵌套函数，可实现递归 下单函数MQL4中只有一个下单函数：Ordersend()，下单函数的属性，参照订单参数。 发送订单时，币种是必须要给予的。币种的类型是string（字符串类型的），可以有以下几种表现形式： 调用Symbol()：Symbol()函数是MQL4内部定义函数，返回当前加载EA图表中的币种。 直接指定：使用字符串指定，如欧元兑美元可直接使用”EURUSD” 间接指定：定义一个货币对字符串，然后使用这个字符串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123; string 币种=Symbol(),注释=\"测试\"; double 单量=0.1,开仓价=Ask; int 滑点=3,魔数=1243; double 止损=开仓价-100*Point,止盈=开仓价+100*Point; datetime 过期时间=0; int ticket=0; ticket=OrderSend(币种,OP_BUY,单量,开仓价,滑点,止损,止盈,注释,魔数,过期时间,clrNONE); if(ticket==0) Print(\"开单失败！错误原因：\",GetLastError()); else Print(\"开单成功！订单号：\",ticket); GetSymInfo(); &#125;//----获得币种的各种信息----//void GetSymInfo()&#123; string 货币对名=\"EURUSD\"; double 买价,卖价,多仓隔夜利息,空仓隔夜利息,最低点位; double 点差,报价位数; double 最低单量; 买价=MarketInfo(货币对名,MODE_ASK); 卖价=MarketInfo(货币对名,MODE_BID); 多仓隔夜利息=MarketInfo(货币对名,MODE_SWAPLONG); 空仓隔夜利息=MarketInfo(货币对名,MODE_SWAPSHORT); 点差=MarketInfo(货币对名,MODE_SPREAD); 报价位数=MarketInfo(货币对名,MODE_DIGITS); 最低点位=MarketInfo(货币对名,MODE_POINT); 最低单量=MarketInfo(货币对名,MODE_MINLOT); Print(\"货币对 :\", 货币对名 ); Print(\"买价 :\", 买价 ); Print(\"卖价 :\", 卖价 ); Print(\"多仓隔夜利息:\", 多仓隔夜利息 ); Print(\"空仓隔夜利息:\", 空仓隔夜利息 ); Print(\"点差 :\", 点差 ); Print(\"报价位数 :\", 报价位数 ); Print(\"最低点位 :\", 最低点位 ); Print(\"最低单量 :\", 最低单量 ); &#125; /*-----订单类型-------多单 OP_BUY空单 OP_SELL买入限价 OP_BUYLIMIT 等价位跌倒某值买入买入止损 OP_SELLLIMIT 等价格涨到某值卖出卖出限价 OP_BUYSTOP 等价格涨到某值买入（一般为突破多挂单）卖出止损 OP_SELLSTOP 等价格跌倒某值卖出（一般为跌破空挂单）----------------------*/ 修改订单函数MQL4中修改订单，使用OrderModify()函数。对于已经下单的订单，能够修改的参数只有止损和止盈。对于挂单，可以修改止损，止盈和开仓价 修改订单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strict/*----------修改订单使用 OrderModify() 函数--- 本例将所有 多单的止损扩大100点 空单的止盈扩大100点 ---------------------------------------------*/bool res;void OnStart() &#123; for(int i=0;i&lt;OrdersTotal();i++) &#123; if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==True) &#123; if(OrderType()==OP_BUY || OrderType()==OP_BUYLIMIT || OrderType()==OP_BUYSTOP) &#123; if(OrderStopLoss()==0) &#123; res=OrderModify(OrderTicket(),OrderOpenPrice(),MarketInfo(OrderSymbol(),MODE_ASK)-100*MarketInfo(OrderSymbol(),MODE_POINT),OrderTakeProfit(),0,clrNONE); if(res==false) Print(\"多单修改失败，订单号：\",OrderTicket()); &#125; else &#123; res=OrderModify(OrderTicket(),OrderOpenPrice(),OrderStopLoss()+100*MarketInfo(OrderSymbol(),MODE_POINT),OrderTakeProfit(),0,clrNONE); if(res==false) Print(\"空单修改失败，订单号：\",OrderTicket()); &#125; &#125; if(OrderType()==OP_SELL || OrderType()==OP_SELLLIMIT || OrderType()==OP_SELLSTOP) &#123; if(OrderTakeProfit()==0) &#123; res=OrderModify(OrderTicket(),OrderOpenPrice(),OrderStopLoss(),MarketInfo(OrderSymbol(),MODE_BID)-100*MarketInfo(OrderSymbol(),MODE_POINT),0,clrNONE); if(res==false) Print(\"空单修改失败，订单号：\",OrderTicket()); &#125; else &#123; res=OrderModify(OrderTicket(),OrderOpenPrice(),OrderStopLoss(),OrderTakeProfit()-100*MarketInfo(OrderSymbol(),MODE_POINT),0,clrNONE); if(res==false) Print(\"空单修改失败，订单号：\",OrderTicket()); &#125; &#125; &#125; &#125; &#125; 平仓函数MQL4对已开仓位使用平仓函数，可将仓位按当前价平仓。 删除订单函数MQL4对未执行的挂单使用删除订单函数，将此挂单删除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strict/*---------------------------------------------平仓函数的使用需要慎重对待，必须使用订单号平仓，一般的使用方式为先选中订单，然后再平仓。本例：在图表周期中，若K线收盘价低于10日均线时，平掉本货币对多仓----------------------------------------------*/input int 周期=10;int 魔数=1243;int OnInit() &#123; return(INIT_SUCCEEDED); &#125;void OnDeinit(const int reason) &#123; &#125;void OnTick() &#123; double ma_value=iMA(Symbol(),0,周期,0,MODE_EMA,PRICE_CLOSE,0);//--调用均线指标 double close_price=iClose(Symbol(),0,0); //------调用收盘价 if(close_price&lt;ma_value) &#123; for(int i=0;i&lt;OrdersTotal();i++) &#123; if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==True) &#123; //----------------选择需要平仓的订单---------------、、 if(OrderSymbol()==Symbol() &amp;&amp; OrderMagicNumber()==魔数) &#123;//----------------开仓单使用OrderClose() ----------// if(OrderType()==OP_BUY) &#123; if(!OrderClose(OrderTicket(),OrderLots(),MarketInfo(Symbol(),MODE_BID),3,clrNONE)) Alert(\"平仓失败，错误号：\",GetLastError()); &#125;//-----------------挂单使用 OrderDelete() ----------// if(OrderType()==OP_BUYLIMIT || OrderType()==OP_BUYSTOP) &#123; if(!OrderDelete(OrderTicket(),clrNONE)) Alert(\"删除挂单失败，错误号：\",GetLastError()); &#125; &#125; &#125; &#125; &#125; &#125; 自定义函数自定义函数用于实现特定的功能。函数有以下属性 函数的形式：函数需写在主体程序之外，如下： 返回值：函数可以带有返回值，定义类型与返回类型需一致。 无返回值：对于不需要返回值的函数，定义类型用void。 123456789101112131415161718192021222324252627282930313233343536/*----函数的基本结构-----//返回值类型 函数名(参数类型 参数定义,参数类型 参数定义)&#123; 函数主体&#125;*/#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strict//+------------------------------------------------------------------+//| OnStart()也是一个函数，并且没有返回值 |//+------------------------------------------------------------------+void OnStart() &#123; Acc_check(); //---没有参数 int a=1,b=2,c=3,res; res = add(a,b,c,4);//---有4个参数，与函数定义需一一对应 Print(\"res:\",res); &#125; void Acc_check()&#123; if(!IsDemo()) &#123; Alert(\"非模拟账户，请谨慎操作！\"); &#125; return;&#125;int add(int aa,int bb,int cc,int dd)&#123; int r=0; r=aa+bb+cc+dd; return r;&#125; 控制语句控制语句是实现策略的主要方法，在程序中非常重要，控制语句的执行代码需要用大括号括起来。 if条件判断if是条件判断语句，若条件为True（真）时，执行if内容，否则不执行。 if-else条件判断若if判断条件为真，执行if的内容，否则执行else里面的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;//-----23点到1点之间不交易------// if(TimeHour(TimeCurrent())==23 || TimeHour(TimeCurrent())==0) //--函数带有括号() &#123; Alert(\"非交易时段\"); return; &#125; //--- else 并不是一定要有，根据需要-------////--- 本根K线RSI指标高于50下空单，低于50下多单----// double rsi_value=iRSI(Symbol(),0,14,PRICE_CLOSE,0); int ticket=0; if(rsi_value&gt;50) &#123; ticket=OrderSend(Symbol(),OP_SELL,0.1,Bid,3,0,0,\"测试\",1242,0,clrNONE); if(ticket==0) Print(\"开单失败！错误原因：\",GetLastError()); else Print(\"开单成功！订单号：\",ticket); &#125; else &#123; ticket=OrderSend(Symbol(),OP_BUY,0.1,Ask,3,0,0,\"测试\",1242,0,clrNONE); if(ticket==0) Print(\"开单失败！错误原因：\",GetLastError()); else Print(\"开单成功！订单号：\",ticket); &#125; //--- 本根K线RSI指标高于70下空单，低于30下多单,其他情况不下单----// if(rsi_value&gt;70) &#123; ticket=OrderSend(Symbol(),OP_SELL,0.1,Bid,3,0,0,\"测试\",1242,0,clrNONE); if(ticket==0) Print(\"开单失败！错误原因：\",GetLastError()); else Print(\"开单成功！订单号：\",ticket); &#125; else if(rsi_value&lt;30) // else if 追加判断 &#123; ticket=OrderSend(Symbol(),OP_BUY,0.1,Ask,3,0,0,\"测试\",1242,0,clrNONE); if(ticket==0) Print(\"开单失败！错误原因：\",GetLastError()); else Print(\"开单成功！订单号：\",ticket); &#125; &#125; for循环for循环，在任何编程语言中都占据重要的地位。很复杂的类似操作，使用for循环将会变得简单。for循环需要定义循环次数，通常情况下使用如下：12345678910111213141516171819202122232425#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;//-----做1到100的累加----// int sum=0; for(int i=1;i&lt;=100;i++) &#123; sum=sum+i; &#125; Print(\"1到100的累加结果为：\",sum); int i=1; sum=0; while(i&lt;=100) &#123; sum=sum+i; &#125; Print(\"1到100的累加结果为：\",sum); &#125; while循环while循环是一直循环，只要条件满足就执行，在没有停止条件的情况下会一直执行。没有停止条件的情况下，会无限循环，导致程序陷入死循环，有时会崩溃。在可选的条件下，尽量不用。 123456789101112131415161718#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;//-----做1到100的累加----// int sum=0; int i=1; while(i&lt;=100) &#123; sum=sum+i; &#125; Print(\"1到100的累加结果为：\",sum); &#125; switch-case条件选择根据switch的内容，选定相应的case。使用switch-case时，需要事情拟定所有可能的情况。 123456789101112131415161718192021222324252627#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strictvoid OnStart() &#123;//-----选择下单方式----// int type=OP_BUY; switch(type) &#123; case OP_BUY: Print(\"下多单\"); break; case OP_BUYLIMIT: Print(\"下限价买入挂单\"); break; case OP_SELL: Print(\"下空单\"); break; default: Print(\"其他情况，不操作\"); break; &#125; &#125; continue 循环中断在循环语句的代码中，执行到continue时，将直接进入下一次循环。 break 循环结束在循环语句的代码中，执行到break时，循环将被终止。 订单参数每一个订单都有自己的参数，在使用OrderSelect()选中订单的前提下，可使用内置函数调用订单参数。在未选中的情况下，无法返回参数。选择订单的两种方法： 按订单号选择 按订单序列选择 订单号使用OrderTicket()返回订单得订单号，数据类型为整型 币种使用OrderSymbol()函数返回订单币种，类型为string（字符串） 单量使用OrderLots()函数返回订单单量，类型为一个浮点数 交易类型使用OrderType()函数返回订单方向，可能是OP_BUY,OP_SELL,OP_BUY_LIMIT,OP_BUY_STOP,OP_SELL_LIMIT,OP_SELL_STOP中的其中一个 开仓价使用OrderOpenPrice()返回订单得订单开仓价，数据类型为整型 开仓时间使用OrderOpenTime()返回订单得订单开仓时间，数据类型为整型 止损使用OrderStopLoss()返回订单得订单止损，数据类型为整型 止盈使用OrderTakeProfit()返回订单得订单止盈，数据类型为整型 注释使用OrderComment()返回订单得订单注释，数据类型为整型 魔数使用OrderMagicNumber()返回订单得订单魔数，数据类型为整型 平仓价使用OrderClosePrice()返回订单得订单平仓价，数据类型为整型 平仓时间使用OrderCloseTime()返回订单得订单平仓时间，数据类型为整型 浮盈使用OrderProfit()返回订单得订单浮盈，数据类型为整型 隔夜利息使用OrderSwap()返回订单得订单隔夜利息，数据类型为整型 手续费使用OrderCommission()返回订单得订单手续费，数据类型为整型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#property copyright \"shiyingpan\"#property link \"https://aijy.github.io\"#property version \"1.00\"#property strict/*--------------------------------选择订单参数是智能交易中的重要步骤。----------------------------------*/void OnStart() &#123;//-------------通用格式----------- for(int i=0;i&lt;=OrdersTotal()-1;i++) //---------选择持仓订单 &#123; if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)) &#123; Print(\"订单号：\",OrderTicket()); Print(\"币种：\",OrderSymbol()); Print(\"方向：\",OrderType()); Print(\"单量：\",OrderLots()); Print(\"开仓价：\",OrderOpenPrice()); Print(\"开仓时间：\",OrderOpenTime()); Print(\"止损：\",OrderStopLoss()); Print(\"止盈：\",OrderTakeProfit()); Print(\"收盘价：\",OrderClosePrice()); Print(\"收盘时间：\",OrderCloseTime()); Print(\"魔数：\",OrderMagicNumber()); Print(\"注释：\",OrderComment()); Print(\"浮盈：\",OrderProfit()); Print(\"隔夜利息：\",OrderSwap()); Print(\"手续费：\",OrderCommission()); &#125; &#125; for(int i=0;i&lt;=OrdersHistoryTotal()-1;i++) //---------选择历史订单 &#123; if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)) &#123; Print(\"订单号：\",OrderTicket()); Print(\"币种：\",OrderSymbol()); Print(\"方向：\",OrderType()); Print(\"单量：\",OrderLots()); Print(\"开仓价：\",OrderOpenPrice()); Print(\"开仓时间：\",OrderOpenTime()); Print(\"止损：\",OrderStopLoss()); Print(\"止盈：\",OrderTakeProfit()); Print(\"收盘价：\",OrderClosePrice()); Print(\"收盘时间：\",OrderCloseTime()); Print(\"魔数：\",OrderMagicNumber()); Print(\"注释：\",OrderComment()); Print(\"浮盈：\",OrderProfit()); Print(\"隔夜利息：\",OrderSwap()); Print(\"手续费：\",OrderCommission()); &#125; &#125; //------------直接按订单号选择------- int ticket=123; if(OrderSelect(ticket,SELECT_BY_TICKET)) //----直接按订单号选择需输入正确订单号，很少用 &#123; Print(\"订单号：\",OrderTicket()); Print(\"币种：\",OrderSymbol()); Print(\"方向：\",OrderType()); Print(\"单量：\",OrderLots()); Print(\"开仓价：\",OrderOpenPrice()); Print(\"开仓时间：\",OrderOpenTime()); Print(\"止损：\",OrderStopLoss()); Print(\"止盈：\",OrderTakeProfit()); Print(\"收盘价：\",OrderClosePrice()); Print(\"收盘时间：\",OrderCloseTime()); Print(\"魔数：\",OrderMagicNumber()); Print(\"注释：\",OrderComment()); Print(\"浮盈：\",OrderProfit()); Print(\"隔夜利息：\",OrderSwap()); Print(\"手续费：\",OrderCommission()); &#125; &#125; 编程风格养成良好的编程风格 良好的书写格式，有助于理清思路，检验策略，查找错误，美观，这是基本功。 多使用函数，对于一个功能块，使用一个函数代替。 多次使用的字符串或数字，用一个标示符代替。 使用MetaEditor的自带编程风格工具","categories":[{"name":"MQL4课程","slug":"MQL4课程","permalink":"http://aijy.github.io/categories/MQL4课程/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://aijy.github.io/tags/教程/"}]},{"title":"MQL4问题与解答","slug":"常见问题与解答","date":"2018-01-01T00:00:00.000Z","updated":"2018-05-31T06:46:18.896Z","comments":true,"path":"常见问题与解答.html","link":"","permalink":"http://aijy.github.io/常见问题与解答.html","excerpt":"","text":"本页将把常见的问题与解答展示在本页","categories":[{"name":"问题与解答","slug":"问题与解答","permalink":"http://aijy.github.io/categories/问题与解答/"}],"tags":[{"name":"MQL4问题与解答","slug":"MQL4问题与解答","permalink":"http://aijy.github.io/tags/MQL4问题与解答/"}]}]}